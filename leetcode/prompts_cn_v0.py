import textwrap

SYSTEM_PROMPT = textwrap.dedent("""
You are a pragmatic Python expert. You prefer 'Simple is better than complex'. You always look for standard library solutions first.
""").strip()

# ==========================================
# 1. 初始执行提示词 (包含 Few-Shot 示例)
# ==========================================
INITIAL_PROMPT_TEMPLATE = textwrap.dedent("""
你是一位精通算法与 Python 的资深工程师。
请根据以下示例和任务要求编写 Python 函数。

---

**示例（Few-Shot Example）**：

**任务**: 
给定一个整数数组 nums (长度 <= 1000)，求其最长递增子序列的长度。

**你的回答**:
<think>
1. **约束分析**: 数组长度 N <= 1000。这意味着 O(N^2) 的算法是可以接受的。
2. **算法思路**: 这是一个经典的动态规划问题。
   - 定义 dp[i] 为以 nums[i] 结尾的最长递增子序列长度。
   - 状态转移: dp[i] = max(dp[j]) + 1，其中 0 <= j < i 且 nums[j] < nums[i]。
   - 最终结果是 max(dp)。
</think>

<code>
from typing import List

def lengthOfLIS(nums: List[int]) -> int:
    if not nums:
        return 0
    dp = [1] * len(nums)
    for i in range(len(nums)):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return max(dp)
</code>

---

任务: {task}

请严格遵循以下三个步骤进行输出（不要省略任何步骤）：

1. **方案竞标** (在 <brainstorm> 标签内):
   - **需求分析**: 分析输入输出格式和约束条件（数据规模）。
   - **算法选择**: 根据数据规模推断合适的时间复杂度（如 N<=100 -> O(N^3), N<=10^5 -> O(N log N)）。根据问题类型（最大化总分、路径计数等）选择算法（如动态规划、贪心或图论等）。
   - 列出至少 2 种解决此问题的可能方法（例如：暴力法 vs 动态规划，或 状态机 vs 正则表达式）。
   - 对比每种方法的：
     * 时间复杂度
     * 代码实现复杂度（代码行数与出错概率）
   - **决策**: 明确选择一种“实现最简洁且不容易出错”的方法。

2. **思考和详细设计阶段** (在 <think> 标签内):
   - 根据你在 <brainstorm> 中选择的方法，设计具体步骤。
   - **边界预判**: 列出 2-3 个可能的极端情况（如空输入、最大值、负数等）即可。
   - **方案设计**: 简述算法步骤。

3. **编码阶段** (在 <code> 标签内):
   - 编写完整的、符合 PEP 8 规范的 Python 代码。
   - 包含必要的导入 (import) 和辅助函数。

请直接输出，不要包含任何标签之外的闲聊。

<think>
在此处写下你的分析...
</think>

<code>
在此处写下你的代码...
</code>
""").strip()

# ==========================================
# 2. 反思提示词
# ==========================================
REFLECT_PROMPT_TEMPLATE = textwrap.dedent("""
你是一位极其严格的代码评审专家。请检查代码的逻辑正确性和性能。

# 原始任务:
{task}

# 待审查的代码:
{code}

请严格遵循以下流程进行审查，防止过度分析：

**重要警示**：
1. **严禁**在思考过程中逐字符模拟正则表达式的匹配过程（例如："字符 'a' 匹配 '\\d' 吗？不..."）。这会导致死循环！
2. 仅从**逻辑覆盖面**进行检查。

<think>
1. **复杂度检查**: 估算代码的时间复杂度。结合任务描述中的约束条件，判断是否会超时 (TLE)。
2. **逻辑验证**:
   - 请仅构造 **3个** 具有代表性的测试场景:
     (1) 一个普通用例。
     (2) 一个边缘用例（如空值、极值）。
     (3) 一个容易出错的特殊用例。
   - 对这 3 个用例进行脑内模拟，直接给出预期结果，**不要**解释匹配过程。
3. **结论**: 如果上述 3 个用例通过，且复杂度达标，则认为代码通过。**严禁**尝试更多用例。
</think>

请在 <feedback> 标签内输出结构化反馈：

<feedback>
[整体评价]
(简短评价。如果代码逻辑正确且简洁，输出 GOOD。如果代码过于复杂且有更简单的解法，必须标记为 **需要重构**)

[逻辑漏洞]
(如果发现未覆盖的情况，请指出；否则输出 None)

[改进建议]
(如果存在致命 Bug 或性能瓶颈，请给出具体的修复思路；如果代码使用了笨拙的方法，请明确建议：“请放弃当前思路，改用 [更优解法]”；如果代码完美，请直接输出 DONE)
</feedback>
""").strip()

# ==========================================
# 3. 优化提示词
# ==========================================
REFINE_PROMPT_TEMPLATE = textwrap.dedent("""
你是一位资深开发者。根据评审员的反馈，你需要修复或优化代码。

# 原始任务:
{task}

# 评审员反馈:
{feedback}

请严格按照以下格式输出：

<think>
1. **理解反馈**: 评审员是否建议更换核心算法？
2. **新方案**: 如果需要更换，新算法的逻辑是什么？
3. **防错**: 确保不再犯之前的逻辑错误。
4. **定位问题**: 评审员指出的核心问题是什么（是逻辑错误还是性能问题）？
5. **修正策略**: 我将如何修改代码逻辑来解决这个问题？
6. **验证计划**: 确保修改后的代码能处理之前指出的失败用例。
</think>

<code>
# 在此处编写优化后的完整代码
</code>
""").strip()
